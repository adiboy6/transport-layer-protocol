#!/usr/bin/python3 -u
#

import sys
import socket
import datetime
import json

MSG_SIZE = 1500
TIMEOUT = 30
FIN = 5

def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

# Bind to localhost and a port
UDP_IP = "127.0.0.1"
# If there was a specified port number, connect to it.
if (len(sys.argv) == 2):
  # Connect only if an integer value was given, otherwise throw an error and print to console.
  try:
    UDP_PORT = int(sys.argv[1])
  except:
    sys.exit("Error - The port number must be an integer.")
elif (len(sys.argv) == 1):
  UDP_PORT = 0
# If there are any other amounts of arguments
else:
  sys.exit(0)

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((UDP_IP, UDP_PORT))
sock.settimeout(TIMEOUT)

read_data = 0
received_packets = []

while True:
  result = sock.recvfrom(MSG_SIZE)

  # If nothing is ready, we hit the timeout.
  if result:
    (data, address) = result
    data = data.decode("ascii")
    try:
      decoded = json.loads(data)

      # If the 'eof' flag is set, exit.
      if decoded['eof']:
        if decoded['sequence'] == read_data:
          log("[completed]")
          for i in range(FIN):
            # Send back an 'ack' to the sender.
            msg = json.dumps({'ack': decoded['sequence'], 'sack': decoded['sequence']})
            # log("ABOUT TO SEND 'eof' " + msg)
            if sock.sendto(msg.encode("ascii"), address) < len(msg):
              log("[error] unable to fully send packet")
          sys.exit(0)
      else:
        if decoded['data']:
          sequence_number = decoded['sequence']

          current_buffered_sequence_numbers = list(map(lambda packet: packet['sequence'], received_packets))
          if sequence_number >= read_data and not sequence_number in current_buffered_sequence_numbers:
            if sequence_number == read_data:
              log(f"[recv data] {sequence_number} ({len(decoded['data'])}) ACCEPTED (in-order)")
            else:
              log(f"[recv data] {sequence_number} ({len(decoded['data'])}) ACCEPTED (out-of-order)")
            received_packets.append(decoded)
          else:
            log("IGNORED")

        sorted_packets = sorted(received_packets, key=lambda packet: packet['sequence'])
        for packet in sorted_packets:
          if packet['sequence'] == read_data:
            sys.stdout.write(packet['data'])
            read_data = packet['sequence'] + len(packet['data'])
        received_packets = list(filter(lambda packet: packet['sequence'] > read_data, sorted_packets))

        # Send back an 'ack' to the sender.
        msg = json.dumps({'ack': read_data, 'sack': decoded['sequence']})
        # log("ABOUT TO SEND " + msg)
        if sock.sendto(msg.encode("ascii"), address) < len(msg):
          log("[error] unable to fully send packet")

    except (ValueError, KeyError, TypeError) as exc:
      log("[recv corrupt packet]")
      raise exc
  else:
    log("[error] timeout")
    sys.exit(-1)