#!/usr/bin/python3 -u
#

import sys
import socket
import datetime
import json

MSG_SIZE = 1500
TIMEOUT = 30

# Message Fields
SEQ_NO = "sequence"
ACK = "ack"
SACK = "sack"
DATA = "data"
EOF = "eof"

FIN = 5

def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

# Bind to localhost and a port
UDP_IP = "127.0.0.1"
# If there was a specified port number, connect to it.
if (len(sys.argv) == 2):
  # Connect only if an integer value was given, otherwise throw an error and print to console.
  try:
    UDP_PORT = int(sys.argv[1])
  except:
    sys.exit("Error - The port number must be an integer.")
elif (len(sys.argv) == 1):
  UDP_PORT = 0
# If there are any other amounts of arguments
else:
  sys.exit(0)

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((UDP_IP, UDP_PORT))
sock.settimeout(TIMEOUT)

read_data = 0
received_packets = []

while True:
  result = sock.recvfrom(MSG_SIZE)

  # If nothing is ready, we hit the timeout.
  if result:
    (data, address) = result
    data = data.decode("ascii")
    try:
      decoded = json.loads(data)

      # If the EOF flag is set, exit.
      if decoded[EOF]:
        if decoded[SEQ_NO] == read_data:
          log("[completed]")
          for i in range(FIN):
            # Send back an ACK to the sender.
            msg = json.dumps({ACK: decoded[SEQ_NO], SACK: decoded[SEQ_NO]})
            # log("ABOUT TO SEND EOF " + msg)
            if sock.sendto(msg.encode("ascii"), address) < len(msg):
              log("[error] unable to fully send packet")
          sys.exit(0)
      else:
        if decoded[DATA]:
          sequence_number = decoded[SEQ_NO]

          current_buffered_sequence_numbers = list(map(lambda packet: packet[SEQ_NO], received_packets))
          if sequence_number >= read_data and not sequence_number in current_buffered_sequence_numbers:
            if sequence_number == read_data:
              log(f"[recv data] {sequence_number} ({len(decoded[DATA])}) ACCEPTED (in-order)")
            else:
              log(f"[recv data] {sequence_number} ({len(decoded[DATA])}) ACCEPTED (out-of-order)")
            received_packets.append(decoded)
          else:
            log("IGNORED")

        sorted_packets = sorted(received_packets, key=lambda packet: packet[SEQ_NO])
        for packet in sorted_packets:
          if packet[SEQ_NO] == read_data:
            sys.stdout.write(packet[DATA])
            read_data = packet[SEQ_NO] + len(packet[DATA])
        received_packets = list(filter(lambda packet: packet[SEQ_NO] > read_data, sorted_packets))

        # Send back an ACK to the sender.
        msg = json.dumps({ACK: read_data, SACK: decoded[SEQ_NO]})
        # log("ABOUT TO SEND " + msg)
        if sock.sendto(msg.encode("ascii"), address) < len(msg):
          log("[error] unable to fully send packet")

    except (ValueError, KeyError, TypeError) as exc:
      log("[recv corrupt packet]")
      raise exc
  else:
    log("[error] timeout")
    sys.exit(-1)