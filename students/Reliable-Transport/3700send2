#!/usr/bin/env python3

import sys
import socket
import datetime
import json
import time

ENCODING = "ascii"

MSG_SIZE = 1500
DATA_SIZE = 500
TIMEOUT = 0.099

# Message Fields
SEQN = "sequence"
DATA = "data"
ACK = "ack"
SACK = "sack"
EOF = "eof"

# Packet Fields
MSG = "packet message"
PST = "packet send time"
PTO = "packet timeout"
PRT = "packet retransmissions"

ALPHA = 0.875
ADVERTISED_WINDOW = 15
INITIAL_RTT = 0.1


def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")
    sys.stderr.flush()


def send_packet(sock, destination, sequence_number, data, sent_packets, rtt):
    msg = {SEQN: sequence_number, DATA: data, ACK: False, EOF: False}
    if sock.sendto(json.dumps(msg, ensure_ascii=False).encode(ENCODING), destination) < len(msg):
        log("[error] unable to fully send packet")
    else:
        log(f"[send data] {sequence_number} ({len(data)})")
        packet_send_time = time.time()
        packet_timeout = packet_send_time + (2 * rtt)
        sent_packets[sequence_number] = {MSG: msg, PST: packet_send_time, PTO: packet_timeout, PRT: 0}


def send_next_packet(sock, destination, sequence_number, data_transmission_complete, sent_packets, rtt):
    msg = {SEQN: sequence_number, DATA: "", ACK: False, EOF: False}
    data = sys.stdin.read(DATA_SIZE)
    msg[DATA] = data
    if data_transmission_complete:
        return

    if len(msg[DATA]) > 0:
        assert len(msg) <= DATA_SIZE, f"ERROR: Datagram is longer ({len(msg)}) than {DATA_SIZE} bytes."
        send_packet(sock, destination, sequence_number, data, sent_packets, rtt)
        sequence_number += len(msg[DATA])
    else:
        eof_msg = {EOF: True, DATA: "", SEQN: sequence_number, ACK: False}
        send_packet(sock, destination, sequence_number, "", sent_packets, rtt)
        data_transmission_complete = True

    return sequence_number, data_transmission_complete


def retransmit_packet(sock, destination, sequence_number, sent_packets, rtt):
    packet = sent_packets[sequence_number]
    msg = packet[MSG]
    send_packet(sock, destination, sequence_number, msg[DATA], sent_packets, rtt)


def update_rtt(rtt, sent_packet):
    if sent_packet[PRT] == 0:
        packet_send_time = sent_packet[PST]
        old_rtt = rtt
        new_sample = time.time() - packet_send_time
        new_rtt = ALPHA * old_rtt + (1.0 - ALPHA) * new_sample
        rtt = new_rtt


def handle_ack(decoded, sent_packets, rtt):
    if decoded[SACK] in sent_packets:
        sent_packet = sent_packets[decoded[SACK]]
        update_rtt(rtt, sent_packet)
        del sent_packets[decoded[SACK]]

    unacknowledged_sequence_numbers = list(sent_packets.keys())
    for sequence_number in unacknowledged_sequence_numbers:
        if sequence_number < decoded[ACK]:
            del sent_packets[sequence_number]


def send_remaining_packets(sock, destination, sent_packets, data_transmission_complete, sequence_number, rtt):
    while len(sent_packets) < ADVERTISED_WINDOW and not data_transmission_complete:
        sequence_number, data_transmission_complete = send_next_packet(
            sock, destination, sequence_number, data_transmission_complete, sent_packets, rtt
        )

    return sequence_number, data_transmission_complete


def handle_received_data(sock, sent_packets, data_transmission_complete, sequence_number, rtt, destination):
    last_packet_receive_time = time.time()

    try:
        result = sock.recvfrom(MSG_SIZE)
    except socket.timeout:
        result = None

    if result:
        last_packet_receive_time = time.time()
        (data, _address) = result
        data = data.decode(ENCODING)

        try:
            decoded = json.loads(data)
            log(f"[recv ack] {decoded[ACK]}")
            handle_ack(decoded, sent_packets, rtt)
            sequence_number, data_transmission_complete = send_remaining_packets(
                sock, destination, sent_packets, data_transmission_complete, sequence_number, rtt
            )

            if len(sent_packets) == 0 and data_transmission_complete:
                log("[completed]")
                sys.exit(0)
        except (ValueError, KeyError, TypeError):
            log("[recv corrupt packet]")

    return last_packet_receive_time


def handle_timeout(last_packet_receive_time, sent_packets, rtt, sock, destination):
    current_time = time.time()
    if (current_time - last_packet_receive_time) > (TIMEOUT * 1000):
        log("[error] timeout")
        sys.exit(-1)
    else:
        for sequence_number in sent_packets:
            sent_packet = sent_packets[sequence_number]
            if current_time > sent_packet[PTO]:
                retransmit_packet(sock, destination, sequence_number, sent_packets, rtt)


def run(sock, destination):
    sequence_number = 0
    rtt = INITIAL_RTT
    sent_packets = dict()
    data_transmission_complete = False
    last_packet_receive_time = time.time()

    last_packet_receive_time = time.time()
    while len(sent_packets) < ADVERTISED_WINDOW and not data_transmission_complete:
        sequence_number, data_transmission_complete = send_next_packet(
            sock, destination, sequence_number, data_transmission_complete, sent_packets, rtt
        )

    while True:
        last_packet_receive_time = handle_received_data(
            sock, sent_packets, data_transmission_complete, sequence_number, rtt, destination
        )
        handle_timeout(last_packet_receive_time, sent_packets, rtt, sock, destination)


def main():
    ip_port = sys.argv[1]
    udp_ip = ip_port[0:ip_port.find(":")]
    udp_port = int(ip_port[ip_port.find(":") + 1:])
    destination = (udp_ip, udp_port)
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(TIMEOUT)

    run(sock, destination)


if __name__ == '__main__':
    main()
